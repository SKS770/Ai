# 1st question


import heapq
# Goal State
goal_state = "123456780"   # 0 = blank
# Moves: Up, Down, Left, Right
moves = {
    0: [1, 3],
    1: [0, 2, 4],
    2: [1, 5],
    3: [0, 4, 6],
    4: [1, 3, 5, 7],
    5: [2, 4, 8],
    6: [3, 7],
    7: [4, 6, 8],
    8: [5, 7]
}
# Manhattan Distance Heuristic
def manhattan(state):
    dist = 0
    for i, val in enumerate(state):
        if val != "0":
            goal_pos = int(val) - 1
            dist += abs(i // 3 - goal_pos // 3) + abs(i % 3 - goal_pos % 3)
    return dist
# Generate next states
def get_neighbors(state):
    zero_pos = state.index("0")
    neighbors = []
    for move_pos in moves[zero_pos]:
        new_state = list(state)
        new_state[zero_pos], new_state[move_pos] = new_state[move_pos], new_state[zero_pos]
        neighbors.append("".join(new_state))
    return neighbors
# A* Search Algorithm
def a_star(start_state):
    pq = []  # priority queue
    heapq.heappush(pq, (manhattan(start_state), 0, start_state, []))
    visited = set()
    while pq:
        f, g, state, path = heapq.heappop(pq)
        if state in visited:
            continue
        visited.add(state)
        if state == goal_state:
            return path + [state]
        for next_state in get_neighbors(state):
            if next_state not in visited:
                heapq.heappush(pq, (g + 1 + manhattan(next_state), g + 1, next_state, path + [state]))
    return None
# Print Puzzle
def print_state(state):
    for i in range(0, 9, 3):
        print(state[i], state[i+1], state[i+2])
    print()
# Main program
start_state = input("Enter initial 8-puzzle state (e.g. 125340678): ")
solution = a_star(start_state)
if solution:
    print("\nSolution found!\n")
    for step in solution:
        print_state(step)
else:
    print("No solution exists.")
