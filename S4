# 1st question

import random
# List of words for the game
words = ["python", "hangman", "computer", "science", "programming", "artificial"]
# Choose a random word
word = random.choice(words)
guessed = ["_"] * len(word)
attempts = 6
used_letters = []
print(" Welcome to Hangman Game ")
print("Guess the word!")
while attempts > 0 and "_" in guessed:
    print("\nWord:", " ".join(guessed))
    print("Attempts left:", attempts)
    print("Used letters:", ", ".join(used_letters))
    guess = input("Enter a single alphabet: ").lower()
    # Validate input
    if len(guess) != 1 or not guess.isalpha():
        print("Please enter only one alphabet.")
        continue
     if guess in used_letters:
        print("You already guessed this letter.")
        continue
    used_letters.append(guess)
    # Check if guessed correctly
    if guess in word:
        print("âœ” Good guess!")
        for i in range(len(word)):
            if word[i] == guess:
                guessed[i] = guess
    else:
        print(" Wrong guess!")
        attempts -= 1
# Result
if "_" not in guessed:
    print("\n Congratulations! You guessed the word:", word)
else:
    print("\n You lost! The word was:", word)



# 2) Write a Python program to implement Breadth First Search algorithm. 
Refer the following graph as an Input for the program.[Initial 
node=1,Goal node=8]

from collections import deque
def bfs(graph, start, goal):
    visited = set()               # To keep track of visited nodes
    queue = deque([[start]])      # Queue for BFS (stores paths)
    while queue:
        path = queue.popleft()    # Get first path from queue
        node = path[-1]           # Get the last node in the path
        # If goal node found
        if node == goal:
            return path
        # If node not visited, explore neighbors
        if node not in visited:
            visited.add(node)
            for neighbour in graph.get(node, []):
                new_path = list(path)
                new_path.append(neighbour)
                queue.append(new_path)
    return None   # If goal not reachable
# Example graph (you can modify this as needed)
graph = {
    1: [2, 4],
    2: [3],
    3: [4,6,5],
    4: [2],
    5: [7,8],
    6: [8],
    7: [8],
    8: []
}
# Initial and goal nodes
start_node = 1
goal_node = 8
# Perform BFS
path = bfs(graph, start_node, goal_node)
if path:
    print("Path found:", path)
else:
    print("No path found.")
